//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace GloryDemo {
    using System.Collections.Generic;
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")]
    internal class Test2Parser : GlrTableParser {
        internal static int[][][][] ParseTable = new int[][][][] {
                new int[][][] {
                        new int[][] {
                                new int[] {
                                        1}},
                        new int[][] {
                                new int[] {
                                        6}},
                        null,
                        null,
                        null},
                new int[][][] {
                        null,
                        null,
                        new int[][] {
                                new int[] {
                                        2}},
                        new int[][] {
                                new int[] {
                                        4}},
                        new int[][] {
                                new int[] {
                                        -1}}},
                new int[][][] {
                        new int[][] {
                                new int[] {
                                        3}},
                        new int[][] {
                                new int[] {
                                        6}},
                        null,
                        null,
                        null},
                new int[][][] {
                        null,
                        null,
                        new int[][] {
                                new int[] {
                                        2},
                                new int[] {
                                        0,
                                        0,
                                        0,
                                        2,
                                        0}},
                        new int[][] {
                                new int[] {
                                        4},
                                new int[] {
                                        0,
                                        0,
                                        0,
                                        2,
                                        0}},
                        new int[][] {
                                new int[] {
                                        0,
                                        0,
                                        0,
                                        2,
                                        0}}},
                new int[][][] {
                        new int[][] {
                                new int[] {
                                        5}},
                        new int[][] {
                                new int[] {
                                        6}},
                        null,
                        null,
                        null},
                new int[][][] {
                        null,
                        null,
                        new int[][] {
                                new int[] {
                                        2},
                                new int[] {
                                        1,
                                        0,
                                        0,
                                        3,
                                        0}},
                        new int[][] {
                                new int[] {
                                        4},
                                new int[] {
                                        1,
                                        0,
                                        0,
                                        3,
                                        0}},
                        new int[][] {
                                new int[] {
                                        1,
                                        0,
                                        0,
                                        3,
                                        0}}},
                new int[][][] {
                        null,
                        null,
                        new int[][] {
                                new int[] {
                                        2,
                                        0,
                                        1}},
                        new int[][] {
                                new int[] {
                                        2,
                                        0,
                                        1}},
                        new int[][] {
                                new int[] {
                                        2,
                                        0,
                                        1}}}};
        internal static string[] SymbolTable = new string[] {
                "Expression",
                "integer",
                "add",
                "sub",
                "#EOS",
                "#ERROR"};
        internal static ParseAttribute[][] ParseAttributes = new ParseAttribute[][] {
                new ParseAttribute[] {
                        new ParseAttribute("type", "int"),
                        new ParseAttribute("start", true)},
                new ParseAttribute[] {
                        new ParseAttribute("terminal", true)},
                new ParseAttribute[] {
                        new ParseAttribute("terminal", true)},
                new ParseAttribute[] {
                        new ParseAttribute("terminal", true)},
                new ParseAttribute[0],
                new ParseAttribute[0]};
        internal static int[] ErrorSentinels = new int[0];
        public Test2Parser(IEnumerable<Token> tokenizer) : 
                base(Test2Parser.ParseTable, Test2Parser.SymbolTable, Test2Parser.ParseAttributes, Test2Parser.ErrorSentinels, tokenizer, int.MaxValue) {
        }
        public Test2Parser(IEnumerable<Token> tokenizer, int maxErrorCount) : 
                base(Test2Parser.ParseTable, Test2Parser.SymbolTable, Test2Parser.ParseAttributes, Test2Parser.ErrorSentinels, tokenizer, maxErrorCount) {
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Expression= Expression add Expression | Expression sub Expression | integer
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Expression -> Expression add Expression
        /// Expression -> Expression sub Expression
        /// Expression -> integer
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <returns>The result of the evaluation</returns>
        public static int Evaluate(ParseNode node) {
            return Test2Parser.EvaluateExpression(node, null);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Expression= Expression add Expression | Expression sub Expression | integer
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Expression -> Expression add Expression
        /// Expression -> Expression sub Expression
        /// Expression -> integer
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        public static int Evaluate(ParseNode node, object state) {
            return Test2Parser.EvaluateExpression(node, state);
        }
        /// <summary>
        /// Evaluates a derivation of the form:
        /// Expression= Expression add Expression | Expression sub Expression | integer
        /// </summary>
        /// <remarks>
        /// The production rules are:
        /// Expression -> Expression add Expression
        /// Expression -> Expression sub Expression
        /// Expression -> integer
        /// </remarks>
        /// <param name="node">The <see cref="ParseNode"/> to evaluate</param>
        /// <param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        /// <returns>The result of the evaluation</returns>
        internal static int EvaluateExpression(ParseNode node, object state) {
            if ((GloryDemo.Test2Parser.integer == node.SymbolId)) {
                return ((int)(Test2Parser._ChangeType(node.Value, typeof(int))));
            }
            if ((false == node.IsNonTerminal)) {
                return ((int)(Test2Parser._ChangeType(0, typeof(int))));
            }
            int result = Test2Parser.EvaluateExpression(node.Children[0], state);
            int i = 2;
            for (
            ; (i < node.Children.Length); 
            ) {
                if ((node.Children[(i - 1)].SymbolId == GloryDemo.Test2Parser.add)) {
                    result = (result + Test2Parser.EvaluateExpression(node.Children[i], state));
                }
                else {
                    result = (result - Test2Parser.EvaluateExpression(node.Children[i], state));
                }
                i = (i + 2);
            }
            return ((int)(Test2Parser._ChangeType(result, typeof(int))));
        }
        public const int Expression = 0;
        public const int integer = 1;
        public const int add = 2;
        public const int sub = 3;
        public const int EosSymbol = 4;
        public const int ErrorSymbol = 5;
        private static object _ChangeType(object obj, System.Type type) {
            System.ComponentModel.TypeConverter typeConverter = System.ComponentModel.TypeDescriptor.GetConverter(obj);
            if (((null == typeConverter) 
                        || (false == typeConverter.CanConvertTo(type)))) {
                return System.Convert.ChangeType(obj, type);
            }
            return typeConverter.ConvertTo(obj, type);
        }
    }
}
namespace GloryDemo {
    
}
