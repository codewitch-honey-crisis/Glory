'------------------------------------------------------------------------------
' <auto-generated>
'     This code was generated by a tool.
'     Runtime Version:4.0.30319.42000
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On

Imports System
Imports System.Collections.Generic
Imports System.ComponentModel
Imports System.ComponentModel.Design.Serialization
Imports System.Globalization
Imports System.Text

Namespace GloryDemo
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Class ExpressionParser
        Inherits GlrTableParser
        Friend Shared ParseTable()()()() As Integer = New Integer()()()() {New Integer()()() {New Integer()() {New Integer() {1}}, New Integer()() {New Integer() {2}}, New Integer()() {New Integer() {6}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {-1}}}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {3}}, Nothing, New Integer()() {New Integer() {28}}, New Integer()() {New Integer() {30}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {1, 0, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {1, 0, 1}}}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {4}}, New Integer()() {New Integer() {26}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {0, 0, 1, 4}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {0, 0, 1, 4}}}, New Integer()()() {Nothing, New Integer()() {New Integer() {5}}, New Integer()() {New Integer() {6}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {10, 4, 4, 6, 1}}, New Integer()() {New Integer() {10, 4, 4, 6, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {10, 4, 4, 6, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {10, 4, 4, 6, 1}}}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {7}}, New Integer()() {New Integer() {3, 1, 2}}, New Integer()() {New Integer() {3, 1, 2}}, New Integer()() {New Integer() {22}}, New Integer()() {New Integer() {24}}, Nothing, New Integer()() {New Integer() {3, 1, 2}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {3, 1, 2}}}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {2, 1, 2, 5}}, New Integer()() {New Integer() {2, 1, 2, 5}}, New Integer()() {New Integer() {8}}, New Integer()() {New Integer() {20}}, Nothing, New Integer()() {New Integer() {2, 1, 2, 5}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {2, 1, 2, 5}}}, New Integer()()() {Nothing, Nothing, New Integer()() {New Integer() {9}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {14, 5, 5, 8, 2}}, New Integer()() {New Integer() {14, 5, 5, 8, 2}}, New Integer()() {New Integer() {14, 5, 5, 8, 2}}, New Integer()() {New Integer() {14, 5, 5, 8, 2}}, Nothing, New Integer()() {New Integer() {14, 5, 5, 8, 2}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {14, 5, 5, 8, 2}}}, New Integer()()() {Nothing, Nothing, New Integer()() {New Integer() {11}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {4, 2, 6, 2}}, New Integer()() {New Integer() {4, 2, 6, 2}}, New Integer()() {New Integer() {4, 2, 6, 2}}, New Integer()() {New Integer() {4, 2, 6, 2}}, Nothing, New Integer()() {New Integer() {4, 2, 6, 2}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {4, 2, 6, 2}}}, New Integer()()() {Nothing, Nothing, New Integer()() {New Integer() {13}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {5, 2, 7, 2}}, New Integer()() {New Integer() {5, 2, 7, 2}}, New Integer()() {New Integer() {5, 2, 7, 2}}, New Integer()() {New Integer() {5, 2, 7, 2}}, Nothing, New Integer()() {New Integer() {5, 2, 7, 2}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {5, 2, 7, 2}}}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {6, 2, 3}}, New Integer()() {New Integer() {6, 2, 3}}, New Integer()() {New Integer() {6, 2, 3}}, New Integer()() {New Integer() {6, 2, 3}}, Nothing, New Integer()() {New Integer() {6, 2, 3}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {6, 2, 3}}}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {7, 3, 12}}, New Integer()() {New Integer() {7, 3, 12}}, New Integer()() {New Integer() {7, 3, 12}}, New Integer()() {New Integer() {7, 3, 12}}, Nothing, New Integer()() {New Integer() {7, 3, 12}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {7, 3, 12}}}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {8, 3, 13}}, New Integer()() {New Integer() {8, 3, 13}}, New Integer()() {New Integer() {8, 3, 13}}, New Integer()() {New Integer() {8, 3, 13}}, Nothing, New Integer()() {New Integer() {8, 3, 13}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {8, 3, 13}}}, New Integer()()() {New Integer()() {New Integer() {18}}, New Integer()() {New Integer() {2}}, New Integer()() {New Integer() {6}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {19}}, Nothing, Nothing, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {9, 3, 10, 0, 11}}, New Integer()() {New Integer() {9, 3, 10, 0, 11}}, New Integer()() {New Integer() {9, 3, 10, 0, 11}}, New Integer()() {New Integer() {9, 3, 10, 0, 11}}, Nothing, New Integer()() {New Integer() {9, 3, 10, 0, 11}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {9, 3, 10, 0, 11}}}, New Integer()()() {Nothing, Nothing, New Integer()() {New Integer() {21}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {15, 5, 5, 9, 2}}, New Integer()() {New Integer() {15, 5, 5, 9, 2}}, New Integer()() {New Integer() {15, 5, 5, 9, 2}}, New Integer()() {New Integer() {15, 5, 5, 9, 2}}, Nothing, New Integer()() {New Integer() {15, 5, 5, 9, 2}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {15, 5, 5, 9, 2}}}, New Integer()()() {Nothing, Nothing, New Integer()() {New Integer() {23}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {16, 5, 8, 2}}, New Integer()() {New Integer() {16, 5, 8, 2}}, New Integer()() {New Integer() {16, 5, 8, 2}}, New Integer()() {New Integer() {16, 5, 8, 2}}, Nothing, New Integer()() {New Integer() {16, 5, 8, 2}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {16, 5, 8, 2}}}, New Integer()()() {Nothing, Nothing, New Integer()() {New Integer() {25}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {17, 5, 9, 2}}, New Integer()() {New Integer() {17, 5, 9, 2}}, New Integer()() {New Integer() {17, 5, 9, 2}}, New Integer()() {New Integer() {17, 5, 9, 2}}, Nothing, New Integer()() {New Integer() {17, 5, 9, 2}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {17, 5, 9, 2}}}, New Integer()()() {Nothing, New Integer()() {New Integer() {27}}, New Integer()() {New Integer() {6}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {11, 4, 4, 7, 1}}, New Integer()() {New Integer() {11, 4, 4, 7, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {11, 4, 4, 7, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {11, 4, 4, 7, 1}}}, New Integer()()() {Nothing, New Integer()() {New Integer() {29}}, New Integer()() {New Integer() {6}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {12, 4, 6, 1}}, New Integer()() {New Integer() {12, 4, 6, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {12, 4, 6, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {12, 4, 6, 1}}}, New Integer()()() {Nothing, New Integer()() {New Integer() {31}}, New Integer()() {New Integer() {6}}, New Integer()() {New Integer() {14}}, Nothing, Nothing, New Integer()() {New Integer() {10}}, New Integer()() {New Integer() {12}}, Nothing, Nothing, New Integer()() {New Integer() {17}}, Nothing, New Integer()() {New Integer() {15}}, New Integer()() {New Integer() {16}}, Nothing, Nothing}, New Integer()()() {Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, New Integer()() {New Integer() {13, 4, 7, 1}}, New Integer()() {New Integer() {13, 4, 7, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {13, 4, 7, 1}}, Nothing, Nothing, Nothing, New Integer()() {New Integer() {13, 4, 7, 1}}}}
        Friend Shared SymbolTable() As String = New String() {"Term", "Factor", "Unary", "Leaf", "TermList", "FactorList", "add", "sub", "mul", "div", "lparen", "rparen", "integer", "identifier", "whitespace", "#EOS", "#ERROR"}
        Friend Shared ParseAttributes()() As ParseAttribute = New ParseAttribute()() {New ParseAttribute() {New ParseAttribute("type", "int"), New ParseAttribute("start", true)}, New ParseAttribute() {New ParseAttribute("type", "int")}, New ParseAttribute() {New ParseAttribute("type", "int")}, New ParseAttribute() {New ParseAttribute("type", "int")}, New ParseAttribute() {New ParseAttribute("collapsed", true), New ParseAttribute("nowarn", true), New ParseAttribute("factored", true)}, New ParseAttribute() {New ParseAttribute("collapsed", true), New ParseAttribute("nowarn", true), New ParseAttribute("factored", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("terminal", true)}, New ParseAttribute() {New ParseAttribute("hidden", true)}, New ParseAttribute(-1) {}, New ParseAttribute(-1) {}}
        Friend Shared ErrorSentinels() As Integer = New Integer(-1) {}
        Public Sub New(ByVal tokenizer As IEnumerable(Of Token))
            MyBase.New(ExpressionParser.ParseTable, ExpressionParser.SymbolTable, ExpressionParser.ParseAttributes, ExpressionParser.ErrorSentinels, tokenizer, Integer.MaxValue)
        End Sub
        Public Sub New(ByVal tokenizer As IEnumerable(Of Token), ByVal maxErrorCount As Integer)
            MyBase.New(ExpressionParser.ParseTable, ExpressionParser.SymbolTable, ExpressionParser.ParseAttributes, ExpressionParser.ErrorSentinels, tokenizer, maxErrorCount)
        End Sub
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermList
        '''Term -> Factor
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function Evaluate(ByVal node As ParseNode) As Integer
            Return ExpressionParser.EvaluateTerm(node, Nothing)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermList
        '''Term -> Factor
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Public Overloads Shared Function Evaluate(ByVal node As ParseNode, ByVal state As Object) As Integer
            Return ExpressionParser.EvaluateTerm(node, state)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Term= Factor { ( "+" | "-" ) Factor }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Term -> Factor TermList
        '''Term -> Factor
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Friend Shared Function EvaluateTerm(ByVal node As ParseNode, ByVal state As Object) As Integer
            Dim result As Integer = ExpressionParser.EvaluateFactor(node.Children(0), state)
            Dim i As Integer = 2

            Do While (i < node.Children.Length)
                If (node.Children((i - 1)).SymbolId = GloryDemo.ExpressionParser.add) Then
                    result = (result + ExpressionParser.EvaluateFactor(node.Children(i), state))
                Else
                    result = (result - ExpressionParser.EvaluateFactor(node.Children(i), state))
                End If
                i = (i + 2)

            Loop
            Return CType(ExpressionParser._ChangeType(result, GetType(Integer)),Integer)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Factor= Unary { ( "*" | "/" ) Unary }
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Factor -> Unary FactorList
        '''Factor -> Unary
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Friend Shared Function EvaluateFactor(ByVal node As ParseNode, ByVal state As Object) As Integer
            Dim result As Integer = ExpressionParser.EvaluateUnary(node.Children(0), state)
            Dim i As Integer = 2

            Do While (i < node.Children.Length)
                If (node.Children((i - 1)).SymbolId = GloryDemo.ExpressionParser.mul) Then
                    result = (result * CType(ExpressionParser._EvaluateAny(node.Children(i), state),Integer))
                Else
                    result = (result / CType(ExpressionParser._EvaluateAny(node.Children(i), state),Integer))
                End If
                i = (i + 2)

            Loop
            Return CType(ExpressionParser._ChangeType(result, GetType(Integer)),Integer)
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Unary= ( "+" | "-" ) Unary | Leaf
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Unary -> add Unary
        '''Unary -> sub Unary
        '''Unary -> Leaf
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Friend Shared Function EvaluateUnary(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (node.Children.Length = 1) Then
                Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateLeaf(node.Children(0), state), GetType(Integer)),Integer)
            End If
            If (node.Children(0).SymbolId = GloryDemo.ExpressionParser.add) Then
                Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateUnary(node.Children(1), state), GetType(Integer)),Integer)
            Else
                Return CType(ExpressionParser._ChangeType((0 - ExpressionParser.EvaluateUnary(node.Children(1), state)), GetType(Integer)),Integer)
            End If
        End Function
        '''<summary>
        '''Evaluates a derivation of the form:
        '''Leaf= integer | identifier | "(" Term ")"
        '''</summary>
        '''<remarks>
        '''The production rules are:
        '''Leaf -> integer
        '''Leaf -> identifier
        '''Leaf -> lparen Term rparen
        '''</remarks>
        '''<param name="node">The <see cref="ParseNode"/> to evaluate</param>
        '''<param name="state">A user supplied state object. What it should be depends on the production's associated code block</param>
        '''<returns>The result of the evaluation</returns>
        Friend Shared Function EvaluateLeaf(ByVal node As ParseNode, ByVal state As Object) As Integer
            If (node.Children.Length = 1) Then
                If (node.Children(0).SymbolId = GloryDemo.ExpressionParser.[integer]) Then
                    Return CType(ExpressionParser._ChangeType(node.Children(0).Value, GetType(Integer)),Integer)
                Else
                    If (Not (state) Is Nothing) Then
                        Dim val As Integer
                        Dim d As IDictionary(Of String, Integer) = CType(state,IDictionary(Of String, Integer))
                        If d.TryGetValue(node.Children(0).Value, val) Then
                            Return CType(ExpressionParser._ChangeType(val, GetType(Integer)),Integer)
                        End If
                    End If
                    Throw New Exception(String.Format("Reference to undefined variable {0}", node.Children(0).Value))
                End If
            Else
                Return CType(ExpressionParser._ChangeType(ExpressionParser.EvaluateTerm(node.Children(1), state), GetType(Integer)),Integer)
            End If
        End Function
        Public Const Term As Integer = 0
        Public Const Factor As Integer = 1
        Public Const Unary As Integer = 2
        Public Const Leaf As Integer = 3
        Public Const TermList As Integer = 4
        Public Const FactorList As Integer = 5
        Public Const add As Integer = 6
        Public Const [sub] As Integer = 7
        Public Const mul As Integer = 8
        Public Const div As Integer = 9
        Public Const lparen As Integer = 10
        Public Const rparen As Integer = 11
        Public Const [integer] As Integer = 12
        Public Const identifier As Integer = 13
        Public Const whitespace As Integer = 14
        Public Const EosSymbol As Integer = 15
        Public Const ErrorSymbol As Integer = 16
        Private Shared Function _ChangeType(ByVal obj As Object, ByVal type As System.Type) As Object
            Dim typeConverter As System.ComponentModel.TypeConverter = System.ComponentModel.TypeDescriptor.GetConverter(obj)
            If ((Nothing Is typeConverter)  _
                        OrElse (false = typeConverter.CanConvertTo(type))) Then
                Return System.Convert.ChangeType(obj, type)
            End If
            Return typeConverter.ConvertTo(obj, type)
        End Function
        Private Shared Function _EvaluateAny(ByVal node As ParseNode, ByVal state As Object) As Object
            If (node.SymbolId = ExpressionParser.Term) Then
                Return ExpressionParser.EvaluateTerm(node, state)
            End If
            If (node.SymbolId = ExpressionParser.Factor) Then
                Return ExpressionParser.EvaluateFactor(node, state)
            End If
            If (node.SymbolId = ExpressionParser.Unary) Then
                Return ExpressionParser.EvaluateUnary(node, state)
            End If
            If (node.SymbolId = ExpressionParser.Leaf) Then
                Return ExpressionParser.EvaluateLeaf(node, state)
            End If
            If (node.SymbolId = ExpressionParser.add) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.[sub]) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.mul) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.div) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.lparen) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.rparen) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.[integer]) Then
                Return node.Value
            End If
            If (node.SymbolId = ExpressionParser.identifier) Then
                Return node.Value
            End If
            Return Nothing
        End Function
    End Class
End Namespace

Namespace GloryDemo
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Class GlrTableParser
        Private _parseTable()()()() As Integer
        Private _workers As List(Of GlrWorker)
        Private _worker As GlrWorker
        Private _workerIndex As Integer
        Private _tokenEnum As LookAheadEnumerator
        Private _symbolTable() As String
        Private _attributes()() As ParseAttribute
        Private _errorSentinels() As Integer
        Friend NextWorkerId As Integer
        Private _eosId As Integer
        Private _errorId As Integer
        Private _maxErrorCount As Integer
        Public Sub New(ByVal parseTable()()()() As Integer, ByVal symbolTable() As String, ByVal attributes()() As ParseAttribute, ByVal errorSentinels() As Integer, ByVal tokenizer As IEnumerable(Of Token))
            Me.New(parseTable, symbolTable, attributes, errorSentinels, tokenizer, Integer.MaxValue)
        End Sub
        Public Sub New(ByVal parseTable()()()() As Integer, ByVal symbolTable() As String, ByVal attributes()() As ParseAttribute, ByVal errorSentinels() As Integer, ByVal tokenizer As IEnumerable(Of Token), ByVal maxErrorCount As Integer)
            MyBase.New
            Me._parseTable = parseTable
            Me._symbolTable = symbolTable
            Me._attributes = attributes
            Me._errorSentinels = errorSentinels
            Me._eosId = System.Array.IndexOf(symbolTable, "#EOS")
            If (0 > Me._eosId) Then
                Throw New ArgumentException("Error in symbol table", "symbolTable")
            End If
            Me._errorId = System.Array.IndexOf(symbolTable, "#ERROR")
            If (0 > Me._errorId) Then
                Throw New ArgumentException("Error in symbol table", "symbolTable")
            End If
            Me._tokenEnum = New LookAheadEnumerator(tokenizer.GetEnumerator)
            Me._maxErrorCount = maxErrorCount
            Me.NextWorkerId = 1
            Me._workerIndex = 0
            Me._workers = New List(Of GlrWorker)(8)
            If Me._tokenEnum.MoveNext Then
                Me._workers.Add(New GlrWorker(Me, Me.NextWorkerId, Me._parseTable, Me._errorId, Me._eosId, Me._errorSentinels, Me._workers, Me._tokenEnum))
                Me.NextWorkerId = (Me.NextWorkerId + 1)
            End If
        End Sub
        Public ReadOnly Property TreeId() As Integer
            Get
                Return Me._worker.Id
            End Get
        End Property
        Public ReadOnly Property NodeType() As LRNodeType
            Get
                If Me._worker.HasErrors Then
                    Return LRNodeType.[Error]
                End If
                Return Me._worker.NodeType
            End Get
        End Property
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._worker.CurrentToken.Line
            End Get
        End Property
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._worker.CurrentToken.Column
            End Get
        End Property
        Public ReadOnly Property Position() As Long
            Get
                Return Me._worker.CurrentToken.Position
            End Get
        End Property
        Public ReadOnly Property SymbolId() As Integer
            Get
                Dim n As LRNodeType = Me.NodeType
                If (LRNodeType.Shift = n) Then
                    Return Me._worker.CurrentToken.SymbolId
                End If
                If (LRNodeType.Reduce = n) Then
                    Return Me._worker.RuleDefinition(0)
                End If
                If (LRNodeType.[Error] = n) Then
                    Return Me._errorId
                End If
                If (LRNodeType.EndDocument = n) Then
                    Return Me._eosId
                End If
                Return -1
            End Get
        End Property
        Public ReadOnly Property Attributes() As ParseAttribute()
            Get
                Dim sid As Integer = Me.SymbolId
                If ((-1 < sid)  _
                            AndAlso (Me._attributes.Length > sid)) Then
                    Return Me._attributes(sid)
                End If
                Return Nothing
            End Get
        End Property
        Public ReadOnly Property RuleDefinition() As String()
            Get
                If (false  _
                            = (LRNodeType.Reduce = Me._worker.NodeType)) Then
                    Return Nothing
                End If
                Dim result((Me._worker.RuleDefinition.Length) - 1) As String
                Dim i As Integer = 0
                Do While (i < result.Length)
                    result(i) = Me._symbolTable(Me._worker.RuleDefinition(i))
                    i = (i + 1)
                Loop
                Return result
            End Get
        End Property
        Public ReadOnly Property Rule() As String
            Get
                Dim def() As String = Me.RuleDefinition
                If (Nothing Is def) Then
                    Return Nothing
                End If
                Dim result As String = String.Concat(def(0), " ->")
                Dim i As Integer = 1
                Do While (i < def.Length)
                    result = (result + String.Concat(" ", def(i)))
                    i = (i + 1)
                Loop
                Return result
            End Get
        End Property
        Public ReadOnly Property Symbol() As String
            Get
                Dim sid As Integer = Me.SymbolId
                If (0 > sid) Then
                    Return Nothing
                End If
                Return Me._symbolTable(sid)
            End Get
        End Property
        Public ReadOnly Property Value() As String
            Get
                Return Me._worker.Value
            End Get
        End Property
        Public Function Read() As Boolean
            If (0 = Me._workers.Count) Then
                Return false
            End If
            Me._workerIndex = ((Me._workerIndex + 1)  _
                        Mod Me._workers.Count)
            Me._worker = Me._workers(Me._workerIndex)

            Do While (false = Me._worker.Read)
                Me._workers.RemoveAt(Me._workerIndex)
                If (Me._workerIndex = Me._workers.Count) Then
                    Me._workerIndex = 0
                End If
                If (0 = Me._workers.Count) Then
                    Return false
                End If
                Me._worker = Me._workers(Me._workerIndex)

            Loop
            Dim min As Integer = Integer.MaxValue
            Dim ic As Integer = Me._workers.Count
            Dim i As Integer = 0
            Do While (i < ic)
                Dim w As GlrWorker = Me._workers(i)
                If ((0 < i)  _
                            AndAlso (w.ErrorCount > Me._maxErrorCount)) Then
                    Me._workers.RemoveAt(i)
                    i = (i - 1)
                    ic = (ic - 1)
                End If
                If (min > w.Index) Then
                    min = w.Index
                End If
                If (0 = min) Then
                    i = ic
                End If
                i = (i + 1)
            Loop
            Dim j As Integer = min

            Do While (j > 0)
                Me._tokenEnum.MoveNext
                j = (j - 1)

            Loop
            j = 0
            Do While (j < ic)
                Dim w As GlrWorker = Me._workers(j)
                w.Index = (w.Index - min)
                j = (j + 1)
            Loop
            Return true
        End Function
        Public Overloads Function ParseReductions() As ParseNode()
            Return Me.ParseReductions(false, true, false)
        End Function
        Public Overloads Function ParseReductions(ByVal trim As Boolean, ByVal transform As Boolean, ByVal returnAll As Boolean) As ParseNode()
            Dim map As Dictionary(Of Integer, Stack(Of ParseNode)) = New Dictionary(Of Integer, Stack(Of ParseNode))()
            Dim oldId As Integer = 0
            Dim accepted As Dictionary(Of Integer, Integer) = New Dictionary(Of Integer, Integer)()

            Do While Me.Read
                Dim rs As Stack(Of ParseNode)
                If (false = map.TryGetValue(Me.TreeId, rs)) Then
                    If (false  _
                                = (0 = oldId)) Then
                        Dim l As List(Of ParseNode) = New List(Of ParseNode)(map(oldId))
                        l.Reverse
                        rs = New Stack(Of ParseNode)(l)
                    Else
                        rs = New Stack(Of ParseNode)()
                    End If
                    map.Add(Me.TreeId, rs)
                End If
                Dim p As ParseNode
                Dim n As LRNodeType = Me.NodeType
                If (LRNodeType.Shift = n) Then
                    p = New ParseNode(Me.SymbolId, Me.Symbol, Nothing, Me.Value, Me.Attributes, Me.Line, Me.Column, Me.Position)
                    rs.Push(p)
                Else
                    If (LRNodeType.Reduce = n) Then
                        If ((false = trim)  _
                                    OrElse (false  _
                                    = (2 = Me.RuleDefinition.Length))) Then
                            Dim cl As List(Of ParseNode) = New List(Of ParseNode)()
                            Dim i As Integer = 1
                            Do While (Me.RuleDefinition.Length > i)
                                If (false  _
                                            = (0 = rs.Count)) Then
                                    Dim pc As ParseNode = rs.Pop
                                    Me._AddChildren(pc, transform, cl)
                                    Dim s As String = pc.Symbol
                                    If ("#ERROR" Is s) Then
                                        i = Me.RuleDefinition.Length
                                    End If
                                Else
                                    Dim pc As ParseNode = New ParseNode(Me._errorId, "#ERROR", Nothing, "", Me.Attributes, Me.Line, Me.Column, Me.Position)
                                    Me._AddChildren(pc, transform, cl)
                                End If
                                i = (i + 1)
                            Loop
                            p = New ParseNode(Me.SymbolId, Me.Symbol, cl.ToArray, Nothing, Me.Attributes, Me.Line, Me.Column, Me.Position)
                            rs.Push(p)
                        End If
                    Else
                        If (LRNodeType.[Error] = n) Then
                            p = New ParseNode(Me._errorId, "#ERROR", Nothing, Me.Value, Me.Attributes, Me.Line, Me.Column, Me.Position)
                            rs.Push(p)
                        Else
                            If (LRNodeType.Accept = n) Then
                                accepted.Add(Me.TreeId, 0)
                            End If
                        End If
                    End If
                End If
                oldId = Me.TreeId

            Loop
            Dim result As List(Of ParseNode) = New List(Of ParseNode)(map.Count)
            Dim e As IEnumerator(Of KeyValuePair(Of Integer, Stack(Of ParseNode))) = map.GetEnumerator
            Dim first As Boolean = true

            Do While e.MoveNext
                Dim kvp As KeyValuePair(Of Integer, Stack(Of ParseNode)) = e.Current
                If ((first OrElse returnAll)  _
                            OrElse accepted.ContainsKey(kvp.Key)) Then
                    Dim rs As Stack(Of ParseNode) = kvp.Value
                    If (false  _
                                = (0 = rs.Count)) Then
                        Dim n As ParseNode = rs.Pop
                        Dim cl As List(Of ParseNode) = New List(Of ParseNode)()
                        If n.IsNonTerminal Then
                            cl.AddRange(n.Children)
                        End If
                        Dim s As String = n.Symbol

                        Do While (("#ERROR" <> s)  _
                                    AndAlso (0 < rs.Count))
                            Me._AddChildren(rs.Pop, transform, cl)

                        Loop
                        n = New ParseNode(n.SymbolId, n.Symbol, cl.ToArray, n.Value, n.Attributes, n.Line, n.Column, n.Position)
                        result.Add(n)
                    End If
                End If
                first = false

            Loop
            Return result.ToArray
        End Function
        Public ReadOnly Property Symbols() As String()
            Get
                Return Me._symbolTable
            End Get
        End Property
        Sub _AddChildren(ByVal pc As ParseNode, ByVal transform As Boolean, ByVal result As IList(Of ParseNode))
            If (false = transform) Then
                result.Insert(0, pc)
                Return
            End If
            If pc.IsCollapsed Then
                If (Nothing Is pc.Value) Then
                    Dim ic As Integer = pc.Children.Length
                    Dim i As Integer = (ic - 1)
                    Do While (0 <= i)
                        Me._AddChildren(pc.Children(i), transform, result)
                        i = (i - 1)
                    Loop
                End If
            Else
                result.Insert(0, pc)
            End If
        End Sub
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Class GlrWorker
        Private _parseTable()()()() As Integer
        Private _stack As List(Of Integer)
        Private _tokenEnum As LookAheadEnumerator
        Public CurrentToken As Token
        Public NodeType As LRNodeType
        Public RuleDefinition() As Integer
        Public ErrorCount As Integer
        Public Id As Integer
        Public Index As Integer
        Private _eosId As Integer
        Private _errorId As Integer
        Private _errorSentinels() As Integer
        Private _tupleIndex As Integer
        Private _continuation As Boolean
        Public ErrorTokens As Queue(Of Token)
        Private _workers As IList(Of GlrWorker)
        Private _outerWeak As WeakReference(Of GlrTableParser)
        Property _Outer() As GlrTableParser
            Get
                If (Nothing Is Me._outerWeak) Then
                    Return Nothing
                End If
                Dim result As GlrTableParser
                If Me._outerWeak.TryGetTarget(result) Then
                    Return result
                End If
                Return Nothing
            End Get
            Set
                Me._outerWeak = New WeakReference(Of GlrTableParser)(value)
            End Set
        End Property
        Public Sub New(ByVal outer As GlrTableParser, ByVal id As Integer, ByVal parseTable()()()() As Integer, ByVal errorId As Integer, ByVal eosId As Integer, ByVal errorSentinels() As Integer, ByVal workers As IList(Of GlrWorker), ByVal tokenEnum As LookAheadEnumerator)
            MyBase.New
            Me._Outer = outer
            Me.Id = id
            Me._parseTable = parseTable
            Me._errorId = errorId
            Me._eosId = eosId
            Me._tokenEnum = tokenEnum
            Me._stack = New List(Of Integer)()
            Me.Index = 0
            Me._tupleIndex = 0
            Me._workers = workers
            Me._errorSentinels = errorSentinels
            Me.ErrorTokens = New Queue(Of Token)()
            Me._continuation = false
            Me.NodeType = LRNodeType.Initial
        End Sub
        Public Sub New(ByVal outer As GlrTableParser, ByVal worker As GlrWorker, ByVal tupleIndex As Integer)
            MyBase.New
            Me._Outer = outer
            Me._parseTable = worker._parseTable
            Me._errorId = worker._errorId
            Me._eosId = worker._eosId
            Me._errorSentinels = worker._errorSentinels
            Me.ErrorTokens = New Queue(Of Token)(worker.ErrorTokens)
            Me._tokenEnum = worker._tokenEnum
            Me._stack = New List(Of Integer)(worker._stack.Count)
            Me._stack.AddRange(worker._stack)
            Me.Index = worker.Index
            Me._tupleIndex = tupleIndex
            Me.NodeType = worker.NodeType
            Me.Id = outer.NextWorkerId
            Me.CurrentToken = worker.CurrentToken
            outer.NextWorkerId = (outer.NextWorkerId + 1)
            Me._continuation = true
            Me._workers = worker._workers
        End Sub
        Public Function Read() As Boolean
            If (false  _
                        = (0 = Me.ErrorTokens.Count)) Then
                Dim tok As Token = Me.ErrorTokens.Dequeue
                Return true
            End If
            If Me._continuation Then
                Me._continuation = false
            Else
                Dim n As LRNodeType = Me.NodeType
                If (LRNodeType.Shift = n) Then
                    Me._ReadNextToken
                Else
                    If (LRNodeType.Initial = n) Then
                        Me._stack.Add(0)
                        Me._ReadNextToken
                        Me.NodeType = LRNodeType.[Error]
                    Else
                        If (LRNodeType.EndDocument = n) Then
                            Return false
                        Else
                            If (LRNodeType.Accept = n) Then
                                Me.NodeType = LRNodeType.EndDocument
                                Me._stack.Clear
                                Return true
                            End If
                        End If
                    End If
                End If
            End If
            If (0 < Me._stack.Count) Then
                Dim entry()()() As Integer = Me._parseTable(Me._stack((Me._stack.Count - 1)))
                If (Me._errorId = Me.CurrentToken.SymbolId) Then
                    Me._tupleIndex = 0
                    Me._Panic
                    Return true
                End If
                Dim tbl()() As Integer = entry(Me.CurrentToken.SymbolId)
                If (Nothing Is tbl) Then
                    Me._tupleIndex = 0
                    Me._Panic
                    Return true
                End If
                Dim trns() As Integer = tbl(Me._tupleIndex)
                If (0 = Me._tupleIndex) Then
                    Dim k As Integer = 1
                    Do While (k < tbl.Length)
                        Me._workers.Add(New GlrWorker(Me._Outer, Me, k))
                        k = (k + 1)
                    Loop
                End If
                If (Nothing Is trns) Then
                    Me._Panic
                    Me._tupleIndex = 0
                    Return true
                End If
                If (1 = trns.Length) Then
                    If (false  _
                                = (-1 = trns(0))) Then
                        Me.NodeType = LRNodeType.Shift
                        Me._stack.Add(trns(0))
                        Me._tupleIndex = 0
                        Return true
                    Else
                        If (false  _
                                    = (Me._eosId = Me.CurrentToken.SymbolId)) Then
                            Me._Panic
                            Me._tupleIndex = 0
                            Return true
                        End If
                        Me.NodeType = LRNodeType.Accept
                        Me._stack.Clear
                        Me._tupleIndex = 0
                        Return true
                    End If
                Else
                    Me.RuleDefinition = New Integer(((trns.Length - 1)) - 1) {}
                    Dim i As Integer = 1
                    Do While (i < trns.Length)
                        Me.RuleDefinition((i - 1)) = trns(i)
                        i = (i + 1)
                    Loop
                    Dim j As Integer = 2
                    Do While (j < trns.Length)
                        Me._stack.RemoveAt((Me._stack.Count - 1))
                        j = (j + 1)
                    Loop
                    Dim state As Integer = Me._stack((Me._stack.Count - 1))
                    Dim e()()() As Integer = Me._parseTable(state)
                    If (Nothing Is e) Then
                        Me._Panic
                        Me._tupleIndex = 0
                        Return true
                    End If
                    Me._stack.Add(Me._parseTable(state)(trns(1))(0)(0))
                    Me.NodeType = LRNodeType.Reduce
                    Me._tupleIndex = 0
                    Return true
                End If
            Else
                Me.NodeType = LRNodeType.EndDocument
                Me._tupleIndex = 0
                Return true
            End If
        End Function
        Public ReadOnly Property SymbolId() As Integer
            Get
                If (0 < Me.ErrorTokens.Count) Then
                    Return Me._errorId
                End If
                Dim n As LRNodeType = Me.NodeType
                If (LRNodeType.Reduce = n) Then
                    Return Me.RuleDefinition(0)
                End If
                If (LRNodeType.[Error] = n) Then
                    Return Me._errorId
                End If
                If (LRNodeType.Shift = n) Then
                    Return Me.CurrentToken.SymbolId
                End If
                Return -1
            End Get
        End Property
        Public ReadOnly Property Value() As String
            Get
                If (0 < Me.ErrorTokens.Count) Then
                    Dim err As Token = Me.ErrorTokens.Peek
                    Return err.Value
                End If
                Dim n As LRNodeType = Me.NodeType
                If ((LRNodeType.Shift = n)  _
                            OrElse (LRNodeType.[Error] = n)) Then
                    Return Me.CurrentToken.Value
                End If
                Return Nothing
            End Get
        End Property
        Public ReadOnly Property HasErrors() As Boolean
            Get
                Return (0 < Me.ErrorTokens.Count)
            End Get
        End Property
        Sub _UpdatePositionFinal()
            Dim i As Integer = 0
            Do While (i < Me.CurrentToken.Value.Length)
                Dim ch As Char = Me.CurrentToken.Value(i)
                If (Global.Microsoft.VisualBasic.ChrW(10) = ch) Then
                    Me.CurrentToken.Line = (Me.CurrentToken.Line + 1)
                    Me.CurrentToken.Column = 1
                Else
                    If (Global.Microsoft.VisualBasic.ChrW(13) = ch) Then
                        Me.CurrentToken.Column = 1
                    Else
                        If (Global.Microsoft.VisualBasic.ChrW(9) = ch) Then
                            Me.CurrentToken.Column = (Me.CurrentToken.Column + 4)
                        Else
                            Me.CurrentToken.Column = (Me.CurrentToken.Column + 1)
                        End If
                    End If
                End If
                Me.CurrentToken.Position = (Me.CurrentToken.Position + 1)
                i = (i + 1)
            Loop
        End Sub
        Sub _ReadNextToken()
            Dim tok As Token
            If Me._tokenEnum.TryPeek(Me.Index, tok) Then
                Me.CurrentToken = tok
                If (-1 = Me.CurrentToken.SymbolId) Then
                    Me.CurrentToken.Symbol = "#ERROR"
                    Me.CurrentToken.SymbolId = Me._errorId
                Else
                    Me.CurrentToken.Symbol = Me._Outer.Symbols(Me.CurrentToken.SymbolId)
                End If
                Me.Index = (Me.Index + 1)
            Else
                Me.CurrentToken.Symbol = "#EOS"
                Me.CurrentToken.Value = Nothing
                Me.CurrentToken.SymbolId = Me._eosId
                If (Not (Me.CurrentToken.Value) Is Nothing) Then
                    Me._UpdatePositionFinal
                End If
            End If
        End Sub
        Sub _Panic()
            Dim sa() As Integer = Me._errorSentinels
            If (Nothing Is sa) Then
                sa = New Integer(-1) {}
            End If
            Dim idx As Integer = System.Array.IndexOf(sa, Me.CurrentToken.SymbolId)
            If (-1 < idx) Then
                Me.ErrorCount = (Me.ErrorCount + 1)
                Me.ErrorTokens.Enqueue(Me.CurrentToken)
                Me._ReadNextToken
            End If

            Do While ((false  _
                        = (Me._eosId = Me.CurrentToken.SymbolId))  _
                        AndAlso (0  _
                        > (idx = System.Array.IndexOf(sa, Me.CurrentToken.SymbolId))))
                Me.ErrorCount = (Me.ErrorCount + 1)
                Me.ErrorTokens.Enqueue(Me.CurrentToken)
                Me._ReadNextToken

            Loop
            If (-1 < idx) Then

                Do While (0 < Me._stack.Count)
                    Dim entry()()() As Integer = Me._parseTable(Me._stack((Me._stack.Count - 1)))
                    Dim t()() As Integer = entry(Me.CurrentToken.SymbolId)
                    If (Not (t) Is Nothing) Then
                        Me._continuation = true
                        Return
                    Else
                        Me._stack.RemoveAt((Me._stack.Count - 1))
                    End If

                Loop
            End If
        End Sub
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Class LookAheadEnumerator
        Inherits Object
        Implements IEnumerator(Of Token)
        Private Const _Enumerating As Integer = 0
        Private Const _NotStarted As Integer = -2
        Private Const _Ended As Integer = -1
        Private Const _Disposed As Integer = -3
        Private _inner As IEnumerator(Of Token)
        Private _state As Integer
        Private Const _DefaultCapacity As Integer = 16
        Private Const _GrowthFactor As Single = 0.9!
        Private _queue() As Token
        Private _queueHead As Integer
        Private _queueCount As Integer
        Public Sub New(ByVal inner As IEnumerator(Of Token))
            MyBase.New
            Me._inner = inner
            Me._state = LookAheadEnumerator._NotStarted
            Me._queue = New Token((LookAheadEnumerator._DefaultCapacity) - 1) {}
            Me._queueHead = 0
            Me._queueCount = 0
        End Sub
        Public Sub DiscardLookAhead()

            Do While (1 < Me._queueCount)
                Me._Dequeue

            Loop
        End Sub
        Public ReadOnly Property Current() As Token Implements IEnumerator(Of Token).Current
            Get
                If (0 > Me._state) Then
                    If (LookAheadEnumerator._NotStarted = Me._state) Then
                        Throw New InvalidOperationException("The cursor is before the start of the enumeration.")
                    End If
                    If (LookAheadEnumerator._Ended = Me._state) Then
                        Throw New InvalidOperationException("The cursor is after the end of the enumeration.")
                    End If
                    Throw New ObjectDisposedException(GetType(LookAheadEnumerator).Name)
                End If
                Return Me._queue(Me._queueHead)
            End Get
        End Property
        ReadOnly Property System_Collections_IEnumerator_Current() As Object Implements System.Collections.IEnumerator.Current
            Get
                Return Me.Current
            End Get
        End Property
        Friend ReadOnly Property QueueCount() As Integer
            Get
                Return Me._queueCount
            End Get
        End Property
        Public Function TryPeek(ByVal lookahead As Integer, ByRef value As Token) As Boolean
            If (LookAheadEnumerator._Disposed = Me._state) Then
                Throw New ObjectDisposedException(GetType(LookAheadEnumerator).Name)
            End If
            If (0 > lookahead) Then
                Throw New ArgumentOutOfRangeException("lookahead")
            End If
            If (LookAheadEnumerator._Ended = Me._state) Then
                value = CType(Nothing, Token)
                Return false
            End If
            If (LookAheadEnumerator._NotStarted = Me._state) Then
                If (0 = lookahead) Then
                    value = CType(Nothing, Token)
                    Return false
                End If
            End If
            If (lookahead < Me._queueCount) Then
                value = Me._queue(((lookahead + Me._queueHead)  _
                            Mod Me._queue.Length))
                Return true
            End If
            lookahead = (lookahead - Me._queueCount)
            value = CType(Nothing, Token)

            Do While ((0 <= lookahead)  _
                        AndAlso Me._inner.MoveNext)
                value = Me._inner.Current
                Me._Enqueue(value)
                lookahead = (lookahead - 1)

            Loop
            Return (-1 = lookahead)
        End Function
        Public Function Peek(ByVal lookahead As Integer) As Token
            Dim value As Token
            If (false = Me.TryPeek(lookahead, value)) Then
                Throw New InvalidOperationException("There were not enough values in the enumeration to satisfy the request")
            End If
            Return value
        End Function
        Friend ReadOnly Property IsEnumerating() As Boolean
            Get
                Return (-1 < Me._state)
            End Get
        End Property
        Friend ReadOnly Property IsEnded() As Boolean
            Get
                Return (LookAheadEnumerator._Ended = Me._state)
            End Get
        End Property
        Public ReadOnly Property LookAhead() As IEnumerable(Of Token)
            Get
                If (0 > Me._state) Then
                    If (Me._state = LookAheadEnumerator._NotStarted) Then
                        Throw New InvalidOperationException("The cursor is before the start of the enumeration.")
                    End If
                    If (Me._state = LookAheadEnumerator._Ended) Then
                        Throw New InvalidOperationException("The cursor is after the end of the enumeration.")
                    End If
                    Throw New ObjectDisposedException(GetType(LookAheadEnumerator).Name)
                End If
                Return New LookAheadEnumeratorEnumerable(Me)
            End Get
        End Property
        Public Function MoveNext() As Boolean
            If (0 > Me._state) Then
                If (LookAheadEnumerator._Disposed = Me._state) Then
                    Throw New ObjectDisposedException(GetType(LookAheadEnumerator).Name)
                End If
                If (LookAheadEnumerator._Ended = Me._state) Then
                    Return false
                End If
                If (LookAheadEnumerator._NotStarted = Me._state) Then
                    If (0 < Me._queueCount) Then
                        Me._state = LookAheadEnumerator._Enumerating
                        Return true
                    End If
                    If (false = Me._inner.MoveNext) Then
                        Me._state = LookAheadEnumerator._Ended
                        Return false
                    End If
                    Me._Enqueue(Me._inner.Current)
                    Me._state = LookAheadEnumerator._Enumerating
                    Return true
                End If
            End If
            Me._Dequeue
            If (0 = Me._queueCount) Then
                If (false = Me._inner.MoveNext) Then
                    Me._state = LookAheadEnumerator._Ended
                    Return false
                End If
                Me._Enqueue(Me._inner.Current)
            End If
            Return true
        End Function
        Function System_Collections_IEnumerator_MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext
            Return Me.MoveNext
        End Function
        Sub System_Collections_IEnumerator_Reset() Implements System.Collections.IEnumerator.Reset
            Me._inner.Reset
            Me._queueHead = 0
            Me._queueCount = 0
            Me._state = LookAheadEnumerator._NotStarted
        End Sub
        Sub System_IDisposable_Dispose() Implements System.IDisposable.Dispose
            If (false  _
                        = (LookAheadEnumerator._Disposed = Me._state)) Then
                Me._inner.Dispose
                Me._state = LookAheadEnumerator._Disposed
            End If
        End Sub
        Sub _Enqueue(ByVal item As Token)
            If (Me._queueCount = Me._queue.Length) Then
                Dim arr((CType((Me._queue.Length  _
                            * (1 + LookAheadEnumerator._GrowthFactor)),Integer)) - 1) As Token
                If ((Me._queueHead + Me._queueCount)  _
                            <= Me._queue.Length) Then
                    System.Array.Copy(Me._queue, arr, Me._queueCount)
                    Me._queueHead = 0
                    arr(Me._queueCount) = item
                    Me._queueCount = (Me._queueCount + 1)
                    Me._queue = arr
                Else
                    System.Array.Copy(Me._queue, Me._queueHead, arr, 0, (Me._queue.Length - Me._queueHead))
                    System.Array.Copy(Me._queue, 0, arr, (Me._queue.Length - Me._queueHead), Me._queueHead)
                    Me._queueHead = 0
                    arr(Me._queueCount) = item
                    Me._queueCount = (Me._queueCount + 1)
                    Me._queue = arr
                End If
            Else
                Me._queue(((Me._queueHead + Me._queueCount)  _
                            Mod Me._queue.Length)) = item
                Me._queueCount = (Me._queueCount + 1)
            End If
        End Sub
        Function _Dequeue() As Token
            If (0 = Me._queueCount) Then
                Throw New InvalidOperationException("The queue is empty")
            End If
            Dim result As Token = Me._queue(Me._queueHead)
            Me._queue(Me._queueHead) = CType(Nothing, Token)
            Me._queueHead = (Me._queueHead + 1)
            Me._queueHead = (Me._queueHead Mod Me._queue.Length)
            Me._queueCount = (Me._queueCount - 1)
            Return result
        End Function
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Class LookAheadEnumeratorEnumerable
        Inherits Object
        Implements IEnumerable(Of Token)
        Private _outer As LookAheadEnumerator
        Public Sub New(ByVal outer As LookAheadEnumerator)
            MyBase.New
            Me._outer = outer
        End Sub
        Public Function GetEnumerator() As IEnumerator(Of Token) Implements IEnumerable(Of Token).GetEnumerator
            Dim result As LookAheadEnumeratorEnumerator = CType(System.Activator.CreateInstance(GetType(LookAheadEnumeratorEnumerator), Me._outer),LookAheadEnumeratorEnumerator)
            Return result
        End Function
        Function System_Collections_IEnumerable_GetEnumerator() As System.Collections.IEnumerator Implements System.Collections.IEnumerable.GetEnumerator
            Return Me.GetEnumerator
        End Function
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Class LookAheadEnumeratorEnumerator
        Inherits Object
        Implements IEnumerator(Of Token)
        Private Const _NotStarted As Integer = -2
        Private Const _Ended As Integer = -1
        Private Const _Disposed As Integer = -3
        Private _outer As LookAheadEnumerator
        Private _index As Integer
        Private _current As Token
        Public Sub New(ByVal outer As LookAheadEnumerator)
            MyBase.New
            Me._outer = outer
            If Me._outer.IsEnumerating Then
                Me._current = Me._outer.Current
            End If
            Me._index = LookAheadEnumeratorEnumerator._NotStarted
        End Sub
        Public ReadOnly Property Current() As Token Implements IEnumerator(Of Token).Current
            Get
                If (0 > Me._index) Then
                    If (Me._index = LookAheadEnumeratorEnumerator._NotStarted) Then
                        Throw New InvalidOperationException("The cursor is before the start of the enumeration.")
                    End If
                    If (Me._index = LookAheadEnumeratorEnumerator._Ended) Then
                        Throw New InvalidOperationException("The cursor is after the end of the enumeration.")
                    End If
                    Throw New ObjectDisposedException(GetType(LookAheadEnumeratorEnumerator).Name)
                End If
                Return Me._current
            End Get
        End Property
        ReadOnly Property System_Collections_IEnumerator_Current() As Object Implements System.Collections.IEnumerator.Current
            Get
                Return Me.Current
            End Get
        End Property
        Sub System_IDisposable_Dispose() Implements System.IDisposable.Dispose
            Me._index = LookAheadEnumeratorEnumerator._Disposed
        End Sub
        Function System_Collections_IEnumerator_MoveNext() As Boolean Implements System.Collections.IEnumerator.MoveNext
            Dim value As Token
            If (0 > Me._index) Then
                If (Me._index = LookAheadEnumeratorEnumerator._Disposed) Then
                    Throw New ObjectDisposedException(GetType(LookAheadEnumeratorEnumerator).Name)
                End If
                If (Me._index = LookAheadEnumeratorEnumerator._Ended) Then
                    Return false
                End If
                Me._index = -1
            End If
            Me._index = (Me._index + 1)
            If (false = Me._outer.TryPeek(Me._index, value)) Then
                Me._index = LookAheadEnumeratorEnumerator._Ended
                Return false
            End If
            Me._current = value
            Return true
        End Function
        Sub System_Collections_IEnumerator_Reset() Implements System.Collections.IEnumerator.Reset
            Me._index = LookAheadEnumeratorEnumerator._NotStarted
        End Sub
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Enum LRNodeType As Integer
        Initial = -1
        Shift
        Reduce
        Accept
        [Error]
        EndDocument
    End Enum
    <TypeConverter(GetType(ParseAttributeConverter)),  _
     System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Public Structure ParseAttribute
        Private _name As String
        Private _value As Object
        Public ReadOnly Property Name() As String
            Get
                Return Me._name
            End Get
        End Property
        Public ReadOnly Property Value() As Object
            Get
                Return Me._value
            End Get
        End Property
        Public Sub New(ByVal name As String, ByVal value As Object)
            Me._name = name
            Me._value = value
        End Sub
    End Structure
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Class ParseAttributeConverter
        Inherits TypeConverter
        Public Overrides Function CanConvertTo(ByVal context As ITypeDescriptorContext, ByVal destinationType As Type) As Boolean
            If (GetType(InstanceDescriptor) Is destinationType) Then
                Return true
            End If
            Return MyBase.CanConvertTo(context, destinationType)
        End Function
        Public Overrides Function ConvertTo(ByVal context As ITypeDescriptorContext, ByVal culture As CultureInfo, ByVal value As Object, ByVal destinationType As Type) As Object
            If (GetType(InstanceDescriptor) Is destinationType) Then
                Dim attr As ParseAttribute = CType(value,ParseAttribute)
                Return New InstanceDescriptor(GetType(ParseAttribute).GetConstructor(New Type() {GetType(String), GetType(Object)}), New Object() {attr.Name, attr.Value})
            End If
            Return MyBase.ConvertTo(context, culture, value, destinationType)
        End Function
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Partial Friend Class ParseNode
        Private _symbolId As Integer
        Private _symbol As String
        Private _value As String
        Private _line As Integer
        Private _column As Integer
        Private _position As Long
        Private _children() As ParseNode
        Private _attributes() As ParseAttribute
        Public Sub New(ByVal symbolId As Integer, ByVal symbol As String, ByVal children() As ParseNode, ByVal value As String, ByVal attributes() As ParseAttribute, ByVal line As Integer, ByVal column As Integer, ByVal position As Long)
            MyBase.New
            Me._symbolId = symbolId
            Me._symbol = symbol
            Me._value = Nothing
            Me._children = children
            Me._value = value
            Me._attributes = attributes
            Me._line = line
            Me._column = column
            Me._position = position
        End Sub
        Public ReadOnly Property IsNonTerminal() As Boolean
            Get
                Return (Not (Me._children) Is Nothing)
            End Get
        End Property
        Public ReadOnly Property HasErrors() As Boolean
            Get
                If ("#ERROR" Is Me._symbol) Then
                    Return true
                End If
                If Me.IsNonTerminal Then
                    Dim i As Integer = 0
                    Do While (i < Me.Children.Length)
                        If Me.Children(i).HasErrors Then
                            Return true
                        End If
                        i = (i + 1)
                    Loop
                End If
                Return false
            End Get
        End Property
        Public ReadOnly Property Children() As ParseNode()
            Get
                Return Me._children
            End Get
        End Property
        Public ReadOnly Property SymbolId() As Integer
            Get
                Return Me._symbolId
            End Get
        End Property
        Public ReadOnly Property Symbol() As String
            Get
                Return Me._symbol
            End Get
        End Property
        Public ReadOnly Property Value() As String
            Get
                Return Me._value
            End Get
        End Property
        Public ReadOnly Property Line() As Integer
            Get
                Return Me._line
            End Get
        End Property
        Public ReadOnly Property Column() As Integer
            Get
                Return Me._column
            End Get
        End Property
        Public ReadOnly Property Position() As Long
            Get
                Return Me._position
            End Get
        End Property
        Public ReadOnly Property Attributes() As ParseAttribute()
            Get
                Return Me._attributes
            End Get
        End Property
        Public ReadOnly Property IsCollapsed() As Boolean
            Get
                Dim i As Integer = 0
                Do While (i < Me._attributes.Length)
                    Dim a As ParseAttribute = Me._attributes(i)
                    If ("collapsed" Is a.Name) Then
                        Try 
                            Return CType(a.Value,Boolean)
                        Catch __exception As Exception
                            Return false
                        End Try
                    End If
                    i = (i + 1)
                Loop
                Return false
            End Get
        End Property
        Public Overloads Overrides Function ToString() As String
            Return Me.ToString(Nothing)
        End Function
        Public Overloads Function ToString(ByVal format As String) As String
            If ("t" Is format) Then
                Dim sb As StringBuilder = New StringBuilder()
                ParseNode._AppendTree(Me, sb)
                Return sb.ToString
            End If
            If Me.IsNonTerminal Then
                Return String.Concat(Me.Symbol, ": Count = ", Me._children.Length.ToString)
            End If
            Return String.Concat(Me.Symbol, ": ", Me.Value)
        End Function
        Shared Sub _AppendTree(ByVal node As ParseNode, ByVal builder As System.Text.StringBuilder)
            Dim firstStack As List(Of ParseNode) = New List(Of ParseNode)()
            firstStack.Add(node)
            Dim childListStack As List(Of List(Of ParseNode)) = New List(Of List(Of ParseNode))()
            childListStack.Add(firstStack)

            Do While (childListStack.Count > 0)
                Dim childStack As List(Of ParseNode) = childListStack((childListStack.Count - 1))
                If (childStack.Count = 0) Then
                    childListStack.RemoveAt((childListStack.Count - 1))
                Else
                    node = childStack(0)
                    childStack.RemoveAt(0)
                    Dim indent As String = ""
                    Dim i As Integer = 0
                    Do While (i  _
                                < (childListStack.Count - 1))
                        If (0 < childListStack(i).Count) Then
                            indent = (indent + "|  ")
                        Else
                            indent = (indent + "   ")
                        End If
                        i = (i + 1)
                    Loop
                    Dim s As String = node.Symbol
                    Dim ns As String = ""
                    If (Not (node.Value) Is Nothing) Then
                        ns = node.Value
                    End If
                    Dim ss As String = String.Concat(indent, "+- ", String.Concat(s, " ", ns))
                    ss = ss.TrimEnd
                    builder.Append(ss)
                    builder.AppendLine
                    If (node.IsNonTerminal  _
                                AndAlso (0 < node.Children.Length)) Then
                        Dim pnl As List(Of ParseNode) = New List(Of ParseNode)(node.Children)
                        childListStack.Add(pnl)
                    End If
                End If

            Loop
        End Sub
    End Class
    <System.CodeDom.Compiler.GeneratedCodeAttribute("Glory", "0.1.0.0")>  _
    Friend Structure Token
        Public Symbol As String
        Public SymbolId As Integer
        Public Line As Integer
        Public Column As Integer
        Public Position As Long
        Public Value As String
        Public Overrides Function ToString() As String
            Return String.Concat(Me.Symbol, "(", String.Concat(Me.SymbolId.ToString, ") : ", Me.Value))
        End Function
    End Structure
End Namespace
